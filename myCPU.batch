diff --git a/myCPU/EXE_stage.v b/myCPU/EXE_stage.v
index 79ccc62..74a466f 100644
--- a/myCPU/EXE_stage.v
+++ b/myCPU/EXE_stage.v
@@ -9,12 +9,15 @@ module EXE_stage(
     input  [231:0] ds_to_es_bus,
     //to ms
     output        es_to_ms_valid,
-    output [142:0]es_to_ms_bus,
+    output [143:0]es_to_ms_bus,
     // data sram interface
-    output        data_sram_en,
-    output [ 3:0] data_sram_wen,
+    output        data_sram_req,
+    output        data_sram_wr,
+    output [ 1:0] data_sram_size,
     output [31:0] data_sram_addr,
+    output [ 3:0] data_sram_wstrb,
     output [31:0] data_sram_wdata,
+    input         data_sram_addr_ok,
     // to ds:: for data block
     output [ 4:0] es_to_ds_dest,
     output [31:0] es_to_ds_value,
@@ -93,6 +96,8 @@ wire es_rdcntid;
 wire es_rdcntvl;
 wire es_rdcntvh;
 
+reg data_sram_addr_ok_r;  //hk：exp14 有时需要存储data_sram_addr_ok
+
 assign {
     es_rdcntid,         //231:231
     es_rdcntvl,         //230:230
@@ -134,6 +139,7 @@ assign es_mul_result = {32{es_mul_div_op[0]}} & unsigned_prod[31:0]     //mul
 assign es_to_ms_gr_we = es_gr_we & ~(|es_ex_cause_bus_r);
 
 assign es_to_ms_bus = {
+    es_mem_we,          //143:143
     es_rdcntid,         //142:142
     es_ertn,            //141:141
     es_csr_we,          //140:140
@@ -159,11 +165,12 @@ assign es_final_result = es_mul ? es_mul_result :
 
 
 // this inst is to write reg(gr_we) and it's valid!!
-assign es_to_ds_dest = {5{es_gr_we && es_valid}} & es_dest;
+assign es_to_ds_dest  = {5{es_gr_we && es_valid}} & es_dest;
 assign es_to_ds_value = {32{es_gr_we && es_valid}} & es_alu_result;
-assign es_value_from_mem = es_valid && es_res_from_mem;
+assign es_value_from_mem = /*es_valid &&*/ es_res_from_mem; //hk：exp14这里把es_valid注释掉了，但加上的话可能也能通过
 
-assign es_ready_go    = ~(|es_mul_div_op[6:3] && ~(udiv_done || div_done));//1'b1; // 是div指令，且没有done
+assign es_ready_go    = ((es_res_from_mem || es_mem_we) && ~ws_reflush_es) ? ((data_sram_req & data_sram_addr_ok) || data_sram_addr_ok_r)
+                        : ~(|es_mul_div_op[6:3] && ~(udiv_done || div_done));//1'b1; // 是div指令，且没有done
 assign es_allowin     = !es_valid || es_ready_go && ms_allowin;
 assign es_to_ms_valid =  es_valid && es_ready_go && !ws_reflush_es;
 
@@ -289,9 +296,23 @@ assign es_int = es_ex_cause_bus_r[6'h3];
 assign es_csr = (es_csr_we || es_csr_rd) & es_valid;
 assign es_tid = es_rdcntid & es_valid;
 
-assign data_sram_en    = 1'b1;
-assign data_sram_wen   = (es_mem_we && es_valid && !ms_int && !es_int) ? mem_write_strb : 4'h0;
+//hk:exp14
+always @(posedge clk) begin
+    if(reset) 
+        data_sram_addr_ok_r <= 1'b0;
+    else if(data_sram_addr_ok && data_sram_req && !ms_allowin) 
+        data_sram_addr_ok_r <= 1'b1;    
+    else if(ms_allowin) 
+        data_sram_addr_ok_r <= 1'b0;
+end
+
+assign data_sram_req   = (es_res_from_mem || es_mem_we) && es_valid && ~ws_reflush_es && !data_sram_addr_ok_r && ms_allowin;
+assign data_sram_wr    = |data_sram_wstrb;
+assign data_sram_size  = (es_ld_st_op[4] || es_ld_st_op[7]) ? 2'h2
+                        :(es_ld_st_op[2] || es_ld_st_op[3] || es_ld_st_op[6]) ? 2'h1
+                        :2'h0;
 assign data_sram_addr  = es_alu_result;
+assign data_sram_wstrb = (es_mem_we && es_valid && !ms_int && !es_int) ? mem_write_strb : 4'h0;
 assign data_sram_wdata = mem_write_data;
 
 endmodule
\ No newline at end of file
diff --git a/myCPU/ID_stage.v b/myCPU/ID_stage.v
index 6bd96d5..1336bbe 100644
--- a/myCPU/ID_stage.v
+++ b/myCPU/ID_stage.v
@@ -11,7 +11,7 @@ module ID_stage(
     output         ds_to_es_valid,
     output [231:0] ds_to_es_bus,
     //to fs
-    output [32:0]  br_bus,
+    output [33:0]  br_bus,
     //to rf: for write back
     input  [37:0]  ws_to_rf_bus,
     //from latter stages: to cancel an inst by revising ready_go
@@ -53,6 +53,7 @@ wire        rf_we;
 wire [ 4:0] rf_waddr;
 wire [31:0] rf_wdata;
 
+wire        br_stall;
 wire        br_taken;
 wire [31:0] br_target;
 
@@ -482,6 +483,7 @@ assign br_taken = (   inst_beq  &&  rj_eq_rd
                   ) && ds_valid;
 // assign br_target = (inst_beq || inst_bne || inst_bl || inst_b) ? (ds_pc + br_offs) :
 //                                                    /*inst_jirl*/ (rj_value + jirl_offs);
+assign br_stall = (inst_beq||inst_bne||inst_jirl||inst_bl||inst_b||inst_blt||inst_bltu||inst_bge||inst_bgeu) & !ds_ready_go;
 assign br_target = (inst_beq || inst_bne || inst_blt || inst_bge || inst_bltu || inst_bgeu || inst_bl || inst_b) 
                                                     ? (ds_pc + br_offs) :
                                                    /*inst_jirl*/ (rj_value + jirl_offs);
@@ -505,7 +507,7 @@ always @(posedge clk) begin
     end
 end
 
-assign br_bus       = {br_taken,br_target};
+assign br_bus       = {br_stall,br_taken,br_target};
 
 assign alu_src1 = src1_is_pc  ? ds_pc : rj_value;
 assign alu_src2 = src2_is_imm ? imm : rkd_value;
diff --git a/myCPU/IF_stage.v b/myCPU/IF_stage.v
index 6488616..a4f436e 100644
--- a/myCPU/IF_stage.v
+++ b/myCPU/IF_stage.v
@@ -4,15 +4,19 @@ module IF_stage(
     //allwoin
     input         ds_allowin,
     //brbus
-    input  [32:0] br_bus,
+    input  [33:0] br_bus,
     //to ds
     output        fs_to_ds_valid,
     output [64:0] fs_to_ds_bus,
     // inst sram interface
-    output        inst_sram_en,
-    output [ 3:0] inst_sram_wen,
+    output        inst_sram_req,
+    output        inst_sram_wr,
+    output [ 1:0] inst_sram_size,
     output [31:0] inst_sram_addr,
+    output [ 3:0] inst_sram_wstrb,
     output [31:0] inst_sram_wdata,
+    input         inst_sram_addr_ok,
+    input         inst_sram_data_ok,
     input  [31:0] inst_sram_rdata,
     // reflush
     input  [32:0] ws_reflush_fs_bus
@@ -21,7 +25,19 @@ module IF_stage(
 reg         fs_valid;
 wire        fs_ready_go;
 wire        fs_allowin;
+
+//pre-if
 wire        to_fs_valid;
+wire        to_fs_ready_go; 
+reg         fs_inst_buffer_valid;
+reg  [31:0] fs_inst_buffer;
+reg         inst_sram_addr_ok_r;  //在fs_allowin之前，需要保持inst_sram_addr_ok
+
+//缓存信息
+reg        br_taken_r;
+reg [31:0] br_target_r;
+reg        ws_reflush_pfs_r;
+reg [31:0] ex_entry_r;
 
 wire [31:0] seq_pc;
 wire [31:0] nextpc;
@@ -29,6 +45,7 @@ wire [31:0] nextpc;
 // 考虑是否跳转
 wire        br_taken;
 wire [31:0] br_target;
+wire        br_stall;  //hk：对应讲义P195中间新增信号
 
 // whether ADEF exception occurs
 // ADEF exception should happen at pre-IF stage
@@ -45,7 +62,9 @@ wire [31:0] fs_inst;
 reg  [31:0] fs_pc;
 wire        br_taken_cancel;
 
-assign {br_taken, br_target} = br_bus;
+reg fs_inst_cancel;
+
+assign {br_stall, br_taken, br_target} = br_bus;
 assign fs_to_ds_bus = {fs_inst, 
                        fs_pc, 
                        is_ex_adef};     // 将ADEF异常判断信号传到ID阶段，
@@ -53,15 +72,75 @@ assign fs_to_ds_bus = {fs_inst,
 assign br_taken_cancel = ds_allowin && br_taken;
 
 // pre-IF
-assign to_fs_valid  = ~reset;
-assign seq_pc       = fs_pc + 3'h4;
-assign nextpc       = ws_reflush_fs ? ex_entry :
-                      br_taken ? br_target : seq_pc; 
+assign to_fs_ready_go = (inst_sram_req && inst_sram_addr_ok) || inst_sram_addr_ok_r;
+assign to_fs_valid    = to_fs_ready_go;
+assign seq_pc         = fs_pc + 3'h4;
+assign nextpc         = ws_reflush_pfs_r       ? ex_entry_r 
+                      : ws_reflush_fs          ? ex_entry 
+                      : br_taken_r             ? br_target_r
+                      :(br_taken && !br_stall) ? br_target
+                      : seq_pc;
+
+
+always @(posedge clk) begin
+    if(reset) 
+        inst_sram_addr_ok_r <= 1'b0;
+    else if(inst_sram_addr_ok && inst_sram_req && !fs_allowin)
+        inst_sram_addr_ok_r <= 1'b1;
+    else if(fs_allowin) 
+        inst_sram_addr_ok_r <= 1'b0;
+end
+
+
+always @(posedge clk) begin
+    if(reset) begin
+        br_taken_r  <= 1'b0;
+        br_target_r <= 32'b0;
+    end
+    else if(to_fs_ready_go && fs_allowin) begin
+        br_taken_r  <= 1'b0;
+        br_target_r <= 32'b0;
+    end
+    else if(br_taken && !br_stall) begin
+        br_taken_r  <= 1'b1;
+        br_target_r <= br_target;
+    end
+end
+
+always @(posedge clk) begin
+    if(reset) begin
+        ws_reflush_pfs_r <= 1'b0;
+        ex_entry_r <= 32'b0;
+    end
+    else if(to_fs_ready_go && fs_allowin) begin
+        ws_reflush_pfs_r <= 1'b0;
+        ex_entry_r <= 32'b0;
+    end
+    else if(ws_reflush_fs) begin
+        ws_reflush_pfs_r <= 1'b1;
+        ex_entry_r <= ex_entry;
+    end
+end
+
+//对应讲义P193中间部分 指令在IF缓存
+always @(posedge clk) begin
+    if(reset) 
+        fs_inst_buffer_valid <= 1'b0;
+    else if(!fs_inst_buffer_valid && inst_sram_data_ok && !fs_inst_cancel && !ds_allowin) 
+        fs_inst_buffer_valid <= 1'b1;
+    else if (ds_allowin || ws_reflush_fs) 
+        fs_inst_buffer_valid <= 1'b0;
+
+    if(reset) 
+        fs_inst_buffer <= 32'b0;
+    else if(!fs_inst_buffer_valid && inst_sram_data_ok && !fs_inst_cancel && !ds_allowin)
+        fs_inst_buffer <= inst_sram_rdata;
+end
 
 // IF
-assign fs_ready_go    = 1'b1;
+assign fs_ready_go    = (fs_valid && inst_sram_data_ok || fs_inst_buffer_valid) && ~fs_inst_cancel;
 assign fs_allowin     = !fs_valid || fs_ready_go && ds_allowin;
-assign fs_to_ds_valid =  fs_valid && fs_ready_go && !ws_reflush_fs;
+assign fs_to_ds_valid = fs_valid && fs_ready_go && !ws_reflush_fs && (~br_taken || br_stall);
 
 always @(posedge clk) begin
     if (reset) begin
@@ -70,7 +149,7 @@ always @(posedge clk) begin
     else if (fs_allowin) begin
         fs_valid <= to_fs_valid;
     end
-    else if(br_taken_cancel)
+    else if(br_taken_cancel || ws_reflush_fs) 
         fs_valid <= 1'b0;
 end
 
@@ -78,16 +157,28 @@ always @(posedge clk) begin
     if (reset) begin
         fs_pc <= 32'h1bfffffc;
     end
-    else if (fs_allowin) begin
+    else if (to_fs_ready_go && fs_allowin) begin
         fs_pc <= nextpc;
     end
 end
 
-assign inst_sram_en    = to_fs_valid && fs_allowin;
-assign inst_sram_wen   = 4'h0;
+//fs_inst_cancel 对应P194方法二
+always @(posedge clk) begin
+    if(reset) 
+        fs_inst_cancel <= 1'b0;
+    else if(!fs_allowin && !fs_ready_go && ((ws_reflush_fs) || (br_taken && !br_stall)))
+        fs_inst_cancel <= 1'b1;
+    else if(inst_sram_data_ok)
+        fs_inst_cancel <= 1'b0;
+end
+
+assign inst_sram_req   = ~reset && fs_allowin;
+assign inst_sram_wr    = 1'h0;
+assign inst_sram_size  = 2'h2;
 assign inst_sram_addr  = nextpc;
-assign inst_sram_wdata = 32'b0;
+assign inst_sram_wstrb = 4'h0;
+assign inst_sram_wdata = 32'h0;
 
-assign fs_inst         = inst_sram_rdata;
+assign fs_inst = fs_inst_buffer_valid ? fs_inst_buffer : inst_sram_rdata;
 
 endmodule
\ No newline at end of file
diff --git a/myCPU/MEM_stage.v b/myCPU/MEM_stage.v
index 6ff60f7..9e2ca33 100644
--- a/myCPU/MEM_stage.v
+++ b/myCPU/MEM_stage.v
@@ -6,12 +6,13 @@ module MEM_stage(
     output        ms_allowin    ,
     //from es
     input         es_to_ms_valid,
-    input  [142:0] es_to_ms_bus  ,
+    input [143:0] es_to_ms_bus  ,
     //to ws
     output        ms_to_ws_valid,
-    output [168:0] ms_to_ws_bus  ,
+    output [168:0]ms_to_ws_bus  ,
     //from data-sram
     input  [31:0] data_sram_rdata,
+    input         data_sram_data_ok,
     // to ds:: for data block
     output [ 4:0] ms_to_ds_dest,
     output [31:0] ms_to_ds_value,
@@ -26,8 +27,9 @@ module MEM_stage(
 reg         ms_valid;
 wire        ms_ready_go;
 
-reg [142:0] es_to_ms_bus_r;
+reg [143:0] es_to_ms_bus_r;
 wire [ 4:0] ms_ld_op;
+wire        ms_mem_we;  //hk：exp14 新增信号，表示MEM阶段的store类指令
 wire        ms_res_from_mem;
 wire        ms_gr_we;
 wire [ 4:0] ms_dest;
@@ -53,6 +55,7 @@ assign ms_int = ms_valid & // valid stage
 assign ms_vaddr = ms_alu_result;
 
 assign {
+    ms_mem_we,          //143:143
     ms_rdcntid,         //142:142
     ms_ertn,            //141:141
     ms_csr_we,          //140:140
@@ -94,10 +97,10 @@ assign ms_to_ws_bus = {
     };
 
 // this inst is to write reg(gr_we) and it's valid!!
-assign ms_to_ds_dest = {5{ms_gr_we && ms_valid}} & ms_dest;
+assign ms_to_ds_dest  = {5{ms_gr_we && ms_valid}} & ms_dest; //P195最下面一行  不对！那么写反而不行，在599w出了bug，改回去反而就好了，奇怪
 assign ms_to_ds_value = {32{ms_gr_we && ms_valid}} & ms_final_result;
 
-assign ms_ready_go    = 1'b1;
+assign ms_ready_go    = ((ms_mem_we || ms_res_from_mem) & !ws_reflush_ms) ? data_sram_data_ok : 1'b1;
 assign ms_allowin     = !ms_valid || ms_ready_go && ws_allowin;
 assign ms_to_ws_valid = ms_valid && ms_ready_go && !ws_reflush_ms;
 always @(posedge clk) begin
diff --git a/myCPU/WB_stage.v b/myCPU/WB_stage.v
index d687fc3..7e410e1 100644
--- a/myCPU/WB_stage.v
+++ b/myCPU/WB_stage.v
@@ -157,7 +157,7 @@ assign ws_ecode = (ws_ex_cause_bus[6'h1] & ws_valid) ? `ECODE_SYS
                 : (ws_ex_cause_bus[6'h3] & ws_valid) ? `ECODE_ALE
                 : (ws_ex_cause_bus[6'h4] & ws_valid) ? `ECODE_BRK
                 : (ws_ex_cause_bus[6'h5] & ws_valid) ? `ECODE_INE
-                : 6'b0;
+                : 6'b0;                     // !!!!! 只记录最早报出的例外
 assign ws_esubcode = (ws_ex_cause_bus[6'h2] & ws_valid) ? `ESUBCODE_ADEF
                    : 9'b0;
 assign ws_reflush_ds = ws_valid & // valid stage
diff --git a/myCPU/mycpu_top.v b/myCPU/mycpu_top.v
index 87bec7e..95171ac 100644
--- a/myCPU/mycpu_top.v
+++ b/myCPU/mycpu_top.v
@@ -2,16 +2,35 @@ module mycpu_top(
     input  wire        clk,
     input  wire        resetn,
     // inst sram interface
-    output wire        inst_sram_en,
-    output wire        inst_sram_we,
+    // output wire        inst_sram_en,
+    // output wire        inst_sram_we,
+    // output wire [31:0] inst_sram_addr,
+    // output wire [31:0] inst_sram_wdata,
+    // input  wire [31:0] inst_sram_rdata,
+    output wire        inst_sram_req,   //en
+    output wire        inst_sram_wr,    //|wen
+    output wire [ 1:0] inst_sram_size, 
     output wire [31:0] inst_sram_addr,
+    output wire [ 3:0] inst_sram_wstrb, //wen
     output wire [31:0] inst_sram_wdata,
+    input  wire        inst_sram_addr_ok,
+    input  wire        inst_sram_data_ok,
     input  wire [31:0] inst_sram_rdata,
     // data sram interface
-    output wire        data_sram_en,
-    output wire [ 3:0] data_sram_we,
+    // output wire        data_sram_en,
+    // output wire [ 3:0] data_sram_we,
+    // output wire [31:0] data_sram_addr,
+    // output wire [31:0] data_sram_wdata,
+    // input  wire [31:0] data_sram_rdata,
+
+    output wire        data_sram_req,
+    output wire        data_sram_wr,
+    output wire [ 1:0] data_sram_size,
     output wire [31:0] data_sram_addr,
+    output wire [ 3:0] data_sram_wstrb,
     output wire [31:0] data_sram_wdata,
+    input  wire        data_sram_addr_ok,
+    input  wire        data_sram_data_ok,
     input  wire [31:0] data_sram_rdata,
     // trace debug interface
     output wire [31:0] debug_wb_pc,
@@ -23,6 +42,18 @@ wire         reset;
 //always @(posedge clk) reset <= ~resetn;
 assign reset = ~resetn;
 
+//exp14之前的端口
+// wire        inst_sram_en;
+// wire        inst_sram_we;
+// wire [31:0] inst_sram_addr;
+// wire [31:0] inst_sram_wdata;
+// wire [31:0] inst_sram_rdata;
+// wire        data_sram_en;
+// wire [ 3:0] data_sram_we;
+// wire [31:0] data_sram_addr;
+// wire [31:0] data_sram_wdata;
+// wire [31:0] data_sram_rdata;
+
 wire ds_allowin;
 wire es_allowin;
 wire ms_allowin;
@@ -34,10 +65,10 @@ wire ms_to_ws_valid;
 
 wire [64:0] fs_to_ds_bus;
 wire [231:0] ds_to_es_bus;
-wire [142:0] es_to_ms_bus;
+wire [143:0] es_to_ms_bus;
 wire [168:0] ms_to_ws_bus;
 wire [37:0] ws_to_rf_bus;
-wire [32:0] br_bus;
+wire [33:0] br_bus;
 
 wire [4:0] es_to_ds_dest;
 wire [4:0] ms_to_ds_dest;
@@ -59,19 +90,24 @@ wire ms_csr;
 wire ws_csr;
 wire ms_int;
 
+
 IF_stage if_stage(
-    .clk            (clk            ),
-    .reset          (reset          ),
-    .ds_allowin     (ds_allowin     ),
-    .br_bus         (br_bus         ),
-    .fs_to_ds_valid (fs_to_ds_valid ),
-    .fs_to_ds_bus   (fs_to_ds_bus   ),
-    .inst_sram_en   (inst_sram_en   ),
-    .inst_sram_wen  (inst_sram_we  ),
-    .inst_sram_addr (inst_sram_addr ),
-    .inst_sram_wdata(inst_sram_wdata),
-    .inst_sram_rdata(inst_sram_rdata),
-    .ws_reflush_fs_bus(ws_reflush_fs_bus)
+    .clk               (clk            ),
+    .reset             (reset          ),
+    .ds_allowin        (ds_allowin     ),
+    .br_bus            (br_bus         ),
+    .fs_to_ds_valid    (fs_to_ds_valid ),
+    .fs_to_ds_bus      (fs_to_ds_bus   ),
+    .inst_sram_req     (inst_sram_req  ),
+    .inst_sram_wr      (inst_sram_wr   ),  
+    .inst_sram_size    (inst_sram_size ),
+    .inst_sram_addr    (inst_sram_addr ),
+    .inst_sram_wstrb   (inst_sram_wstrb),
+    .inst_sram_wdata   (inst_sram_wdata),
+    .inst_sram_addr_ok (inst_sram_addr_ok),
+    .inst_sram_data_ok (inst_sram_data_ok),
+    .inst_sram_rdata   (inst_sram_rdata),
+    .ws_reflush_fs_bus (ws_reflush_fs_bus)
 );
 
 
@@ -112,10 +148,13 @@ EXE_stage exe_stage(
     .ds_to_es_bus   (ds_to_es_bus   ),
     .es_to_ms_valid (es_to_ms_valid ),
     .es_to_ms_bus   (es_to_ms_bus   ),
-    .data_sram_en   (data_sram_en   ),
-    .data_sram_wen  (data_sram_we   ),
+    .data_sram_req  (data_sram_req  ),
+    .data_sram_wr   (data_sram_wr   ),
+    .data_sram_size (data_sram_size ),
     .data_sram_addr (data_sram_addr ),
+    .data_sram_wstrb(data_sram_wstrb),
     .data_sram_wdata(data_sram_wdata),
+    .data_sram_addr_ok(data_sram_addr_ok),
     .es_to_ds_dest  (es_to_ds_dest  ),
     .es_to_ds_value (es_to_ds_value ),
     .es_value_from_mem (es_value_from_mem),
@@ -135,6 +174,7 @@ MEM_stage mem_stage(
     .ms_to_ws_valid (ms_to_ws_valid ),
     .ms_to_ws_bus   (ms_to_ws_bus   ),
     .data_sram_rdata(data_sram_rdata),
+    .data_sram_data_ok(data_sram_data_ok),
     .ms_to_ds_dest  (ms_to_ds_dest  ),
     .ms_to_ds_value (ms_to_ds_value ),
     .ws_reflush_ms  (ws_reflush_ms),
